<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Modelo fijo + secciones animan (Three.js + GSAP)</title>
  <style>
    :root{--bg:#0b0d12;--fg:#e9ecf1;--muted:#9aa4b2;--line:#232938}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,sans-serif}
    /* Canvas siempre visible */
    #webgl{position:fixed;inset:0;z-index:0;pointer-events:none}
    /* Contenido */
    main{position:relative;z-index:1}
    section{min-height:100svh;display:grid;align-content:center;gap:1.25rem;padding:6rem 1rem}
    .wrap{max-width:1000px;margin-inline:auto}
    h1{margin:0 0 .25rem;font-size:clamp(2rem,6vw,3.8rem)}
    p.lead{margin:.25rem 0 1.25rem;color:var(--muted);font-weight:500}
    .card{background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.02));border:1px solid var(--line);border-radius:16px;padding:1rem 1.25rem;box-shadow:0 10px 30px rgba(0,0,0,.25)}
    .ui{position:fixed;top:.5rem;left:.5rem;z-index:2;background:#0009;padding:.5rem .6rem;border-radius:8px;font:12px/1.3 ui-monospace,Consolas,Menlo,monospace}
  </style>
  <!-- Import map para Three.js (funciona con Live Server) -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <canvas id="webgl"></canvas>
  <div class="ui" id="ui">Estado: <span id="status">inicializando…</span></div>

  <main>
    <section data-idx="0">
      <div class="wrap">
        <h1 class="reveal">Intro</h1>
        <p class="lead reveal">El modelo está siempre visible; aquí inicia neutro.</p>
        <div class="card reveal">Texto / CTA / links</div>
      </div>
    </section>

    <section data-idx="1">
      <div class="wrap">
        <h1 class="reveal">Detalle</h1>
        <p class="lead reveal">En esta sección el modelo hace zoom in y rota en Y.</p>
        <div class="card reveal">Especificaciones o features.</div>
      </div>
    </section>

    <section data-idx="2">
      <div class="wrap">
        <h1 class="reveal">Exploración</h1>
        <p class="lead reveal">Zoom out y leve tilt en X.</p>
        <div class="card reveal">Storytelling / media / comparativas.</div>
      </div>
    </section>

    <section data-idx="3">
      <div class="wrap">
        <h1 class="reveal">Final</h1>
        <p class="lead reveal">Giro 360° y encuadre final.</p>
        <div class="card reveal">CTA final / contacto.</div>
      </div>
    </section>
  </main>

  <script type="module">
    // ====== Imports ======
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
    import { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';
    import gsap from 'https://cdn.skypack.dev/gsap@3.12.5';
    import ScrollTrigger from 'https://cdn.skypack.dev/gsap@3.12.5/ScrollTrigger';

    gsap.registerPlugin(ScrollTrigger);

    const ui = document.getElementById('status');

    // ====== Escena básica ======
    const canvas = document.getElementById('webgl');
    const scene = new THREE.Scene();
    const renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true});
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));

    const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.01, 500);
    camera.position.set(0, 0.8, 3.2);
    scene.add(camera);

    scene.add(new THREE.AmbientLight(0xffffff, 0.85));
    const dir = new THREE.DirectionalLight(0xffffff, 1.2); dir.position.set(3,4,5); scene.add(dir);

    // ====== Test: cubo (asegura imports OK) ======
    const testCube = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,0.2), new THREE.MeshStandardMaterial({color:0x00a2ff}));
    testCube.position.set(-0.9, 0.2, 0);
    scene.add(testCube);

    // ====== Carga de modelo ======
    const MODEL_URL = './assets/model1.glb';
    const gltfLoader = new GLTFLoader();
    const draco = new DRACOLoader(); draco.setDecoderPath('https://www.gstatic.com/draco/v1/'); gltfLoader.setDRACOLoader(draco);
    const ktx2 = new KTX2Loader(); ktx2.setTranscoderPath('https://unpkg.com/three@0.160.0/examples/jsm/libs/basis/'); ktx2.detectSupport(renderer); gltfLoader.setKTX2Loader(ktx2);

    let model;
    function fitCamera(obj){
      const box = new THREE.Box3().setFromObject(obj);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());
      const maxDim = Math.max(size.x,size.y,size.z)||1;
      const fov = camera.fov * Math.PI/180;
      const dist = Math.abs(maxDim/(2*Math.tan(fov/2))) * 1.28;
      camera.position.set(center.x, center.y + size.y*0.15, Math.min(Math.max(dist,1.0),80));
      camera.near = camera.position.z/100; camera.far = camera.position.z*100; camera.updateProjectionMatrix();
    }

    async function ensureModel(){
      try {
        ui.textContent = 'cargando GLB…';
        const gltf = await gltfLoader.loadAsync(MODEL_URL);
        model = gltf.scene || gltf.scenes?.[0];
        if(!model) throw new Error('GLB sin scene');
        model.traverse(o=>{ if(o.isMesh){ o.castShadow=o.receiveShadow=true; }});
        scene.add(model);
        fitCamera(model);
        ui.textContent = 'modelo listo ✅';
      } catch (e) {
        console.warn('No se cargó GLB. Placeholder activo.', e);
        ui.textContent = '⚠️ No se pudo cargar GLB. Revisa ruta o consola.';
        const donut = new THREE.Mesh(new THREE.TorusKnotGeometry(0.55,0.18,220,30), new THREE.MeshStandardMaterial({color:0x7aa2f7,metalness:.2,roughness:.35}));
        scene.add(donut);
        model = donut;
      }
    }

    await ensureModel();

    // ====== Estados objetivo por sección ======
    const states = [
      { rx: 0.08,  ry: Math.PI*2.00,   rz: 0,   px: 0.02,py: 0.02,pz: 0,   czMul: 0.80 },
      { rx: 0.00,  ry: Math.PI*0.75,   rz: 0,   px: 0.05,py: 0.06, pz: 0,   czMul: 0.70 },
      { rx:-0.12,  ry: Math.PI*1.50,   rz: 0,   px: 0,   py: 0.18, pz: 0,   czMul: 0.25 },
      { rx: 0.08,  ry: Math.PI*2.00,   rz: 0,   px: 0.02,py: 0.02,pz: 0,   czMul: 0.80 }
    ];

    // Proxy animable aplicado al modelo/cámara en onUpdate
    const baseCamZ = camera.position.z;
    const proxy = { rx:0, ry:0, rz:0, px:0, py:0, pz:0, cz: baseCamZ };

    function applyProxy(){
      if(!model) return;
      model.rotation.set(proxy.rx, proxy.ry, proxy.rz);
      model.position.set(proxy.px, proxy.py, proxy.pz);
      camera.position.z = proxy.cz; camera.updateProjectionMatrix();
    }

    // ✅ Clave: NO pin del body. El canvas es fixed y SIEMPRE visible.
    // Creamos un ScrollTrigger por sección que interpola el proxy hacia el estado de esa sección
    document.querySelectorAll('section').forEach((sec, i)=>{
      const s = states[i] || states[states.length-1];
      gsap.to(proxy, {
        rx: s.rx, ry: s.ry, rz: s.rz,
        px: s.px, py: s.py, pz: s.pz,
        cz: baseCamZ * s.czMul,
        ease: 'none',
        scrollTrigger: {
          trigger: sec,
          start: 'top center',
          end: 'bottom center',
          scrub: true
        },
        onUpdate: applyProxy
      });
    });

    // Revelado de contenido (sube y aparece)
    document.querySelectorAll('section').forEach((sec)=>{
      const items = sec.querySelectorAll('.reveal');
      gsap.from(items, {
        y: 40, opacity: 0, duration: 0.8, stagger: 0.12, ease: 'power2.out',
        scrollTrigger: { trigger: sec, start: 'top 70%', end: 'bottom 40%', toggleActions: 'play none none reverse' }
      });
      // Parallax sutil del bloque
      const wrap = sec.querySelector('.wrap');
      if(wrap){
        gsap.fromTo(wrap, { y: 20 }, { y: -20, ease: 'none', scrollTrigger: { trigger: sec, start: 'top bottom', end: 'bottom top', scrub: 1 } });
      }
    });

    // Resize + render loop
    addEventListener('resize', ()=>{ renderer.setSize(innerWidth, innerHeight); camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); });
    renderer.setAnimationLoop(()=>{ testCube.rotation.y += 0.01; renderer.render(scene, camera); });
  </script>
</body>
</html>
