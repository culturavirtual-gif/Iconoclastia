<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Modelo fijo + cámara por secciones</title>
 
 <style>
  :root{--bg:#0b0d12;--fg:#c77b08;--muted:#ffebc7;--line:#232938}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,
    Segoe UI,Roboto,sans-serif}
  #webgl{position:fixed;inset:0;z-index:1;pointer-events:none}
  
  main{position:relative;}
  section{min-height:100svh;display:grid;gap:1.25rem;padding:6rem 1rem}
  section{position:relative; z-index:5}   /* por defecto: sobre el canvas si subes este valor */
  section.front{ z-index:20 }             /* siempre delante del modelo */
  section.behind{ z-index:0 } 

    /* ===== Comportamiento de .wrap (usa variables heredadas) ===== */
  .wrap{
    /* valores por defecto si una sección no define variables */
    --h: start;   /* start | center | end */
    --v: start;   /* start | center | end */
    --x: 100px;      /* offset horizontal */
    --y: 50px;      /* offset vertical */
    --max: 1000px; /* ancho máximo */

    max-width: var(--max);
    position: relative;
    left: var(--x);
    top:  var(--y);
    justify-self: var(--h);
    align-self:    var(--v);
    margin: 0; /* evita pelear con justify-self */
 

  }

  .wrap1{
    /* valores por defecto si una sección no define variables */
    --h: start;   /* start | center | end */
    --v: start;   /* start | center | end */
    --x: 150px;      /* offset horizontal */
    --y: 0px;      /* offset vertical */
    --max: 500px; /* ancho máximo */

    max-width: var(--max);
    position: relative;
    left: var(--x);
    top:  var(--y);
    justify-self: var(--h);
    align-self:    var(--v);
    margin: 0; /* evita pelear con justify-self */
 
  }

    .wrap2{
    /* valores por defecto si una sección no define variables */
    --h: center;   /* start | center | end */
    --v: center;   /* start | center | end */
    --x: 0px;      /* offset horizontal */
    --y: 100px;      /* offset vertical */
    --max: 1000px; /* ancho máximo */

    max-width: var(--max);
    position: relative;
    left: var(--x);
    top:  var(--y);
    justify-self: var(--h);
    align-self:    var(--v);
    margin: 0; /* evita pelear con justify-self */
 
  }

  .wrap3{
    /* valores por defecto si una sección no define variables */
    --h: center;   /* start | center | end */
    --v: center;   /* start | center | end */
    --x: -70px;      /* offset horizontal */
    --y:0px;      /* offset vertical */
    --max: 1000px; /* ancho máximo */

    max-width: var(--max);
    position: relative;
    left: var(--x);
    top:  var(--y);
    justify-self: var(--h);
    align-self:    var(--v);
    margin: 0; /* evita pelear con justify-self */
 
  }

    .wrap4{
    /* valores por defecto si una sección no define variables */
    --h: end;   /* start | center | end */
    --v: center;   /* start | center | end */
    --x: -300px;      /* offset horizontal */
    --y:0px;      /* offset vertical */
    --max: 1000px; /* ancho máximo */

    max-width: var(--max);
    position: relative;
    left: var(--x);
    top:  var(--y);
    justify-self: var(--h);
    align-self:    var(--v);
    margin: 0; /* evita pelear con justify-self */
 
  }
 


  /* Estilos previos conservados */
  h1{margin:0 0 .25rem;font-size:clamp(2rem,6vw,3.8rem)}
  p.lead{margin:.25rem 0 1.25rem;color:var(--muted);font-weight:300}
  .card{
    background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.02));
    border:1px solid var(--line);
    border-radius:16px;
    padding:1rem 1.25rem;
    box-shadow:0 10px 30px rgba(0,0,0,.25)
  }
  .ui{
    position:fixed;top:.5rem;left:.5rem;z-index:2;
    background:#0009;padding:.5rem .6rem;border-radius:8px;
    font:12px/1.3 ui-monospace,Consolas,Menlo,monospace
  }
</style>


  <!-- Import map Three.js -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

</head>
<body>
  <canvas id="webgl"></canvas>
  <div class="ui">Estado: <span id="status">inicializando…</span></div>

  <main>
    <section data-idx="0" class="behind">
      <div class="wrap">
        <h1 class="reveal">Cartografía estética del movimiento Estudiantil<br> UAEMéx 2025</h1>
        <p class="lead reveal">El modelo fijo. La cámara encuadra por sección.</p>
        <div class="card reveal">Texto / CTA / links</div>
      </div>
    </section>

    <section data-idx="1" class="behind">
      <div class="wrap1">
        <h1 class="reveal">Recorridos virtuales</h1>
        <p class="lead reveal">Zoom in y lateral.</p>
        <div class="card reveal">Especificaciones.</div>
      </div>
    </section>

    <section data-idx="2" class="front">
      <div class="wrap2">
        <h1 class="reveal">Inventario 3D</h1>
        <p class="lead reveal">Zoom out y ascenso.</p>
        <div class="card reveal">Storytelling.</div>
      </div>
    </section>

    <section data-idx="3"class="front">
      <div class="wrap3">
        <h1 class="reveal">Archivo</h1>
        <p class="lead reveal">Zoom out y ascenso.</p>
        <div class="card reveal">Storytelling.</div>
      </div>
    </section>

    <section data-idx="4"class="behind">
      <div class="wrap4">
        <h1 class="reveal">Acerca de</h1>
        <p class="lead reveal">Encuadre final.</p>
        <div class="card reveal">CTA.</div>
      </div>
    </section>


   [</main>
  
  <script type="module">
    // ===== Imports =====
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
    import { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import gsap from 'https://esm.sh/gsap@3.12.5';

    const ui = document.getElementById('status');

    // ===== Escena =====
    const canvas = document.getElementById('webgl');
    const scene = new THREE.Scene();
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));

    const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.01, 500);
    camera.position.set(0, 0.8, 3.2);
    scene.add(camera);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.enablePan = false;
    controls.enableZoom = false;
    controls.enableRotate = false;

    scene.add(new THREE.AmbientLight(0xffffff, 0.85));
    const dir = new THREE.DirectionalLight(0xffffff, 1.2); dir.position.set(3,4,5); scene.add(dir);

    // Diagnóstico: cubo
    const testCube = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,0.2), new THREE.MeshStandardMaterial({color:0x00a2ff}));
    testCube.position.set(-0.9, 0.2, 0);
    scene.add(testCube);

    // ===== Modelo =====
   const MODEL_URL = new URL('./assets/model2.glb', import.meta.url).href;
console.log('GLB:', MODEL_URL);
    const gltfLoader = new GLTFLoader();
    const draco = new DRACOLoader(); draco.setDecoderPath('https://www.gstatic.com/draco/v1/'); gltfLoader.setDRACOLoader(draco);
    const ktx2 = new KTX2Loader(); ktx2.setTranscoderPath('https://unpkg.com/three@0.160.0/examples/jsm/libs/basis/'); ktx2.detectSupport(renderer); gltfLoader.setKTX2Loader(ktx2);

    let model;
    function fitCamera(obj){
      const box = new THREE.Box3().setFromObject(obj);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());
      const maxDim = Math.max(size.x,size.y,size.z)||1;
      const fov = camera.fov * Math.PI/180;
      const dist = Math.abs(maxDim/(2*Math.tan(fov/2))) * 0.3;
      camera.position.set(center.x+size.x*-0.10, center.y + size.y*0.15, Math.min(Math.max(dist,1.0),80));
      controls.target.copy(center);
      controls.update();
      camera.near = Math.max(0.01, camera.position.distanceTo(center)/100);
      camera.far  = camera.position.distanceTo(center)*100;
      camera.updateProjectionMatrix();
    }

    async function ensureModel(){
      try {
        ui.textContent = 'cargando GLB…';
        const gltf = await gltfLoader.loadAsync(MODEL_URL);
        model = gltf.scene || gltf.scenes?.[0];
        if(!model) throw new Error('GLB sin scene');
        model.traverse(o=>{ if(o.isMesh){ o.castShadow=o.receiveShadow=true; }});
        scene.add(model);
        fitCamera(model);
        ui.textContent = 'modelo listo ✅';
      } catch (e) {
        console.warn('No se cargó GLB. Placeholder activo.', e);
        ui.textContent = '⚠️ No se pudo cargar GLB. Revisa ruta o consola.';
        const donut = new THREE.Mesh(new THREE.TorusKnotGeometry(0.55,0.18,220,30), new THREE.MeshStandardMaterial({color:0x7aa2f7,metalness:.2,roughness:.35}));
        scene.add(donut);
        model = donut;
        fitCamera(model);
      }
    }

    await ensureModel();

    // ===== Encua­dres: offsets, zoom y yaw/pitch relativos a la base =====
const d2r = Math.PI/180;

const shotsDef = [
  // zMul: 0.6 = zoom-in, 1.0 = igual, 1.3 = zoom-out suave
  { offX: 0.0, offY: 0.0, zMul: 1.0, tarOff:{x:0.00, y:0.00, z:2.00}, yaw: 100, pitch:  10 },

  { offX: 0.0, offY: -2.0, zMul: 0.9, tarOff:{x:5.00, y:0.00, z:10.00}, yaw: 140, pitch:  5 },
    { offX: 0.0, offY: -2.0, zMul: 0.9, tarOff:{x:5.00, y:0.00, z:10.00}, yaw: 150, pitch:  5 },

  { offX: 0.0, offY: -2.0, zMul: 0.9, tarOff:{x:5.00, y:0.00, z:10.00}, yaw: 150, pitch:  5 },
  { offX: 0.0, offY: -1.0, zMul: 0.9, tarOff:{x:1.50, y:0.00, z:0.00}, yaw: 180, pitch:  0 },
  { offX: 0.0, offY: -1.0, zMul: 0.9, tarOff:{x:1.50, y:0.00, z:0.00}, yaw: 190, pitch:  0 },
  { offX: 0.0, offY: -1.5, zMul: 0.5, tarOff:{x:-5, y:0.00, z:5.00}, yaw: 290, pitch:  0 } 
 
];



// Base de orientación actual
const baseTarget = controls.target.clone();
const baseDist   = camera.position.distanceTo(baseTarget);
const worldUp    = new THREE.Vector3(0,1,0);
// Vector desde target hacia la cámara
const baseDir    = camera.position.clone().sub(baseTarget).normalize();

// Convertir a posiciones absolutas con yaw/pitch
function computeShot({offX, offY, zMul, tarOff, yaw, pitch}){
  // gira dirección alrededor de up (yaw) y luego alrededor de right (pitch)
  let dir = baseDir.clone().applyAxisAngle(worldUp, yaw * d2r).normalize();
  let right = new THREE.Vector3().crossVectors(dir, worldUp).normalize();
  dir.applyAxisAngle(right, pitch * d2r).normalize();
  // recalcula bases ortogonales
  right = new THREE.Vector3().crossVectors(dir, worldUp).normalize();
  const up = new THREE.Vector3().crossVectors(right, dir).normalize();

  const target = baseTarget.clone().add(new THREE.Vector3(tarOff.x, tarOff.y, tarOff.z));
  const pos = target.clone()
    .addScaledVector(dir,   baseDist * Math.max(0.01, zMul))
    .addScaledVector(right, offX)
    .addScaledVector(up,    offY);
  return { cam: pos, tar: target };
}
const shots = shotsDef.map(computeShot);

// ===== Timeline pausado controlado por scroll =====
const proxy = {
  cx: camera.position.x, cy: camera.position.y, cz: camera.position.z,
  tx: baseTarget.x, ty: baseTarget.y, tz: baseTarget.z
};

function applyProxy(){
  camera.position.set(proxy.cx, proxy.cy, proxy.cz);
  controls.target.set(proxy.tx, proxy.ty, proxy.tz);
  controls.update(); // no hay roll, OrbitControls no lo anula
}

const tl = gsap.timeline({ paused:true, defaults:{ ease:'none' }, onUpdate: applyProxy });
shots.forEach(s=>{
  tl.to(proxy, { cx:s.cam.x, cy:s.cam.y, cz:s.cam.z, tx:s.tar.x, ty:s.tar.y, tz:s.tar.z, duration:1 });
});

// Scroll -> progreso [0,1]
function setProgressFromScroll(){
  const max = document.documentElement.scrollHeight - innerHeight;
  const u = max > 0 ? Math.min(Math.max(scrollY / max, 0), 1) : 0;
  tl.progress(u);
}
addEventListener('scroll', setProgressFromScroll, { passive:true });
setProgressFromScroll();


    // UI de contenido (opcional sin GSAP plugins)
    // Puedes dejar tus animaciones de texto si ya funcionan.

    // Resize + render
    addEventListener('resize', ()=>{
      renderer.setSize(innerWidth, innerHeight);
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      setProgressFromScroll();
    });

    renderer.setAnimationLoop(()=>{
      testCube.rotation.y += 0.01;
      controls.update();
      renderer.render(scene, camera);
    });

    ui.textContent = 'listo. desplázate para ver los encuadres';

    

  </script>
</body>
</html>
