<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Scroll 3D con Three.js + GSAP (4 apartados)</title>
  
  <style>
    :root { --bg:#0e0e11; --fg:#e8e8ef; --muted:#9aa3b2; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; font-family:system-ui, Segoe UI, Roboto, sans-serif; color:var(--fg); background:var(--bg);}
    /* Canvas fijo */
    #webgl{position:fixed; inset:0; z-index:0; pointer-events:none;}
    /* Contenido scrollable por encima */
    main{position:relative; z-index:1}
    section{min-height:100svh; display:grid; place-content:center; padding:6rem 1.25rem;}
    .wrap{max-width:900px}
    h1,h2{margin:0 0 .5rem 0; line-height:1.1}
    h1{font-size:clamp(2rem,6vw,4.2rem)}
    h2{font-size:clamp(1.2rem,3vw,1.8rem); color:var(--muted); font-weight:500}
    .cta{position:fixed; bottom:1rem; left:50%; translate:-50%; opacity:.6; font-size:.9rem}
    .pin{position:relative}
    .debug{position:fixed; top:.5rem; left:.5rem; background:#0008; padding:.4rem .6rem; font:12px/1.3 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; border-radius:8px; z-index:2}
    a{color:#8ecaff}
  </style>
<!-- Import map para resolver módulos de three.* con Live Server (sin bundler) -->
<script type="importmap">
{
"imports": {
"three": "https://unpkg.com/three@0.160.0/build/three.module.js",
"three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
}
}
</script>
</head>
<body>
  <canvas id="webgl"></canvas>
  <div class="debug" id="debug">cargando…</div>
  <main>
    <section class="pin" data-idx="0">
      <div class="wrap">
        <h1>Intro</h1>
        <h2>El modelo aparece y hace un giro suave. (Sección 1/4)</h2>
      </div>
    </section>
    <section class="pin" data-idx="1">
      <div class="wrap">
        <h1>Detalle</h1>
        <h2>Acercamos cámara (zoom in) y rotamos en Y. (Sección 2/4)</h2>
      </div>
    </section>
    <section class="pin" data-idx="2">
      <div class="wrap">
        <h1>Exploración</h1>
        <h2>Aleja la cámara (zoom out) y eleva en Y. (Sección 3/4)</h2>
      </div>
    </section>
    <section class="pin" data-idx="3">
      <div class="wrap">
        <h1>Final</h1>
        <h2>Nuevo encuadre y giro final de 360°. (Sección 4/4)</h2>
      </div>
    </section>
  </main>
  <div class="cta">Desplázate ↓</div>

  <script type="module">
    // ====== Importes desde CDN (ESM) ======
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/DRACOLoader.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
    import gsap from 'https://cdn.skypack.dev/gsap@3.12.5';
    import ScrollTrigger from 'https://cdn.skypack.dev/gsap@3.12.5/ScrollTrigger';

    gsap.registerPlugin(ScrollTrigger);

    const $d = (id)=>document.getElementById(id);
    const debug = $d('debug');

    // ====== Escena básica ======
    const canvas = document.querySelector('#webgl');
    const scene = new THREE.Scene();
    scene.background = null; // transparente sobre el fondo de la página

    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);

    const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.01, 200);
    camera.position.set(0, 0.75, 3.2);
    scene.add(camera);

    // Luces
    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    const dir = new THREE.DirectionalLight(0xffffff, 1.2);
    dir.position.set(3, 4, 5);
    scene.add(dir);

    // Controles opcionales para pruebas (desactivados en producción)
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enabled = false; // pon a true para probar

    // ====== Carga del modelo GLB ======
    // Coloca tu archivo en /assets/model.glb (o cambia la ruta abajo)
    const MODEL_URL = './assets/model.glb';

    let model; // THREE.Object3D

    const gltfLoader = new GLTFLoader();
    // Si tu GLB está comprimido con Draco, descomenta estas 2 líneas:
    const draco = new DRACOLoader();
    draco.setDecoderPath('https://www.gstatic.com/draco/v1/');
    gltfLoader.setDRACOLoader(draco);

    function fitCameraToObject(object, camera, offset = 1.25) {
      const box = new THREE.Box3().setFromObject(object);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = camera.fov * (Math.PI / 180);
      let cameraZ = Math.abs(maxDim / (2 * Math.tan(fov / 2))) * offset;
      cameraZ = Math.min(Math.max(cameraZ, 1.2), 50);
      camera.position.set(center.x, center.y + size.y * 0.15, cameraZ);
      camera.near = cameraZ / 100;
      camera.far = cameraZ * 100;
      camera.updateProjectionMatrix();
      controls.target.copy(center);
      controls.update();
    }

    async function loadModel() {
      try {
        debug.textContent = 'cargando modelo…';
        const gltf = await gltfLoader.loadAsync(MODEL_URL);
        model = gltf.scene || gltf.scenes[0];
        model.traverse((o)=>{ if(o.isMesh){ o.castShadow = o.receiveShadow = true; o.material.side = THREE.FrontSide; }});
        scene.add(model);
        fitCameraToObject(model, camera, 1.35);
        debug.textContent = 'modelo listo';
      } catch (err) {
        console.error('Fallo cargando GLB, creando placeholder', err);
        debug.textContent = '⚠️ No se pudo cargar el GLB (revisa ruta/CORS). Usando placeholder.';
        // Placeholder para no dejar la pantalla vacía
        const geo = new THREE.TorusKnotGeometry(0.6, 0.2, 200, 32);
        const mat = new THREE.MeshStandardMaterial({ color: 0x89b4fa, metalness:.2, roughness:.35 });
        model = new THREE.Mesh(geo, mat);
        scene.add(model);
        fitCameraToObject(model, camera, 1.35);
      }
    }

    await loadModel();

    // ====== Definición de 4 estados (keyframes) ======
    // Puedes ajustar rotaciones (radianes), posición y z de cámara (zoom)
    const states = [
      { rot:[0, 0, 0], pos:[0, 0, 0], camZ: camera.position.z },
      { rot:[0, Math.PI * 0.75, 0], pos:[0, 0.05, 0], camZ: Math.max(1.2, camera.position.z * 0.65) },
      { rot:[-0.15, Math.PI * 1.5, 0], pos:[0, 0.18, 0], camZ: camera.position.z * 1.25 },
      { rot:[0.1, Math.PI * 2, 0], pos:[0.02, 0.02, 0], camZ: Math.max(1.15, camera.position.z * 0.8) }
    ];

    // ====== Timeline GSAP con ScrollTrigger ======
    const tl = gsap.timeline({
      defaults:{ duration:1, ease:'none' },
      scrollTrigger:{
        trigger: document.body,
        start: 'top top',
        end: '+=400%', // 4 secciones → 400% de viewport
        scrub: 1,
        pin: true,
        anticipatePin: 1,
        onUpdate: (self)=>{ debug.textContent = `progreso ${(self.progress*100).toFixed(1)}%`; }
      }
    });

    // Helper: interpola entre estados
    function addSectionAnim(from, to){
      tl.to({}, { duration:1, onUpdate(){
        const p = this.progress();
        // Interpolación lineal
        const lerp = (a,b,t)=>a+(b-a)*t;
        const r = [
          lerp(from.rot[0], to.rot[0], p),
          lerp(from.rot[1], to.rot[1], p),
          lerp(from.rot[2], to.rot[2], p)
        ];
        const tPos = [
          lerp(from.pos[0], to.pos[0], p),
          lerp(from.pos[1], to.pos[1], p),
          lerp(from.pos[2], to.pos[2], p)
        ];
        const camZ = lerp(from.camZ, to.camZ, p);
        if(model){ model.rotation.set(r[0], r[1], r[2]); model.position.set(tPos[0], tPos[1], tPos[2]); }
        camera.position.z = camZ; camera.updateProjectionMatrix();
      }});
    }

    // Construye 3 transiciones (4 apartados → 3 saltos)
    addSectionAnim(states[0], states[1]);
    addSectionAnim(states[1], states[2]);
    addSectionAnim(states[2], states[3]);

    // ====== Render loop ======
    function onResize(){
      camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    }
    addEventListener('resize', onResize);

    renderer.setAnimationLoop(()=>{ renderer.render(scene, camera); });
  </script>
</body>
</html>
