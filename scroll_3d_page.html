<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF‑8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Scroll‑Driven 3D Model Demo</title>
  <style>
    /*
      Basic resets and typography.
      Each section occupies one viewport height so that the scroll distance
      naturally divides the page into four distinct segments.  A neutral
      background colour keeps the focus on the 3D scene.  The headings are
      intentionally large for impact.
    */
    body {
      margin: 0;
      font-family: sans-serif;
      background: #f8f8f8;
      color: #111;
      overflow-x: hidden;
    }
    h2 {
      font-size: 3rem;
      margin: 0 0 0.5rem;
    }
    p {
      max-width: 40rem;
      line-height: 1.5;
      font-size: 1.1rem;
    }

    /*
      The canvas container is fixed to the viewport and pinned by ScrollTrigger.
      Pointer‑events are disabled so that the page remains scrollable even when
      the pointer passes over the canvas.  A high z‑index keeps the model above
      the page content but below the call‑to‑action in each section.
    */
    #canvas-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 1;
      pointer-events: none;
    }

    /*
      The wrapper for our textual content.  It contains four sections that
      determine the scroll positions.  Each section is a flex container so
      that the text is vertically centred in the viewport.  Feel free to
      customise colours and spacing to suit your own aesthetic.
    */
    #sections {
      position: relative;
      z-index: 2;
    }
    .section {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      padding: 2rem;
    }
    .section:nth-child(odd) {
      background: #ffffff;
    }
    .section:nth-child(even) {
      background: #f0f0f0;
    }

    .section a {
      display: inline-block;
      margin-top: 1rem;
      color: #007acc;
      text-decoration: underline;
    }

    /* A simple scroll hint for the first section */
    .scroll-hint {
      font-size: 1rem;
      opacity: 0.6;
      margin-top: 2rem;
    }
  </style>

   <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

</head>
<body>
  <!-- Fixed container for the 3D canvas -->
  <div id="canvas-container"></div>

  <!-- Scrollable sections.  Each section corresponds to one keyframe in our
       GSAP timeline.  As you scroll, the model will smoothly transition
       between the defined states.  Links demonstrate how each section could
       lead to a separate page. -->
  <div id="sections">
    <div class="section" id="section1">
      <h2>Primer apartado</h2>
      <p>Este primer apartado introduce tu proyecto.  Mientras haces scroll,
         el modelo 3D rota ligeramente y la cámara hace zoom de acercamiento.  Este
         diseño invita al usuario a interactuar con la página.</p>
      <a href="#">Ir al detalle del apartado 1</a>
      <div class="scroll-hint">Desliza hacia abajo para continuar</div>
    </div>
    <div class="section" id="section2">
      <h2>Segundo apartado</h2>
      <p>El segundo apartado puede presentar características adicionales.  La
         animación cambia la orientación del modelo para mostrar otra vista y
         aleja la cámara ligeramente para crear un efecto de zoom out.  Puedes
         enlazar este apartado a otra página o proyecto.</p>
      <a href="#">Ir al detalle del apartado 2</a>
    </div>
    <div class="section" id="section3">
      <h2>Tercer apartado</h2>
      <p>Aquí podrías mostrar otra faceta del mismo modelo o cambiar su
         posición.  Cada transición está sincronizada con el desplazamiento del
         usuario gracias a GSAP ScrollTrigger.  Ajusta los valores en el
         código para personalizar la rotación y el zoom.</p>
      <a href="#">Ir al detalle del apartado 3</a>
    </div>
    <div class="section" id="section4">
      <h2>Cuarto apartado</h2>
      <p>El último apartado concluye la historia.  El modelo gira a un ángulo
         final y la cámara se aleja para revelar el conjunto.  Usa este espacio
         para un call‑to‑action o información de contacto.</p>
      <a href="#">Ir al detalle del apartado 4</a>
    </div>
  </div>

  <!-- Include Three.js, GLTFLoader and GSAP from CDN.  These external
       libraries provide 3D rendering and scroll based animation.  If you
       prefer to self‑host them, download the files and update the src
       attributes accordingly. -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/ScrollTrigger.min.js"></script>

 
 
 
 
 
 <script>
    // Ensure the ScrollTrigger plugin is registered
    gsap.registerPlugin(ScrollTrigger);

    // Variables to hold Three.js objects
    let scene, camera, renderer, model;

    // Initialise the Three.js scene
    function initThree() {
      scene = new THREE.Scene();

      // Create a perspective camera with a moderate field of view
      const fov = 35;
      const aspect = window.innerWidth / window.innerHeight;
      camera = new THREE.PerspectiveCamera(fov, aspect, 0.1, 100);
      camera.position.set(0, 1, 6);

      // Add some lights.  A hemi light for ambient fill and a directional
      // light to cast highlights on the model.
      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
      hemiLight.position.set(0, 1, 0);
      scene.add(hemiLight);
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(5, 10, 7.5);
      scene.add(dirLight);

      // Create the WebGL renderer and append it to the canvas container.
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;

      document.getElementById('canvas-container').appendChild(renderer.domElement);

      // Start the render loop
      animate();
    }

    // Helper: adjust camera and renderer on resize
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener('resize', onWindowResize);

    // Main animation loop
    function animate() {
      requestAnimationFrame(animate);
      // Always required to update any active animations (e.g. GSAP timeline)
      renderer.render(scene, camera);
    }

    // Load a GLB model.  If loading fails (e.g. due to CORS restrictions)
    // create a fallback geometry so the demo still runs.  Replace
    // `modelUrl` with the path to your own .glb file.
    function loadModel() {
      const loader = new THREE.GLTFLoader();
      const modelUrl = './assets/model.glb'; // replace with your GLB path

      loader.load(
        modelUrl,
        (gltf) => {
          model = gltf.scene;
          model.traverse((child) => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
          // Optional: scale the model down if it appears too large
          model.scale.set(1.5, 1.5, 1.5);
          scene.add(model);
          setupScrollAnimation();
        },
        undefined,
        (error) => {
          console.warn('No se pudo cargar el modelo GLB, se usará una geometría de prueba:', error);
          // fallback: create a torus knot geometry so the page remains interactive
          const geometry = new THREE.TorusKnotGeometry(1, 0.3, 100, 16);
          const material = new THREE.MeshStandardMaterial({ color: 0x4a90e2, metalness: 0.5, roughness: 0.4 });
          model = new THREE.Mesh(geometry, material);
          scene.add(model);
          setupScrollAnimation();
        }
      );
    }

    // Define the scroll‑driven animation using GSAP ScrollTrigger.  A timeline
    // with four sequential segments is created.  Each segment corresponds to
    // one of the four sections in the HTML.  Within each segment we animate
    // the model’s rotation and the camera’s distance (z position).  Feel free
    // to tweak the numeric values to suit your own model and narrative.
    function setupScrollAnimation() {
      // Ensure a model exists before constructing the timeline
      if (!model) return;

      // Pin the canvas container throughout the scroll range.  Without this
      // explicit pin, the canvas would scroll away with the document.
      ScrollTrigger.create({
        trigger: '#sections',
        start: 'top top',
        end: 'bottom bottom',
        pin: '#canvas-container',
        pinSpacing: true,
      });

      // Build a GSAP timeline.  The progress of this timeline is tied to
      // scrolling via a ScrollTrigger.  The timeline’s duration (4 units) is
      // deliberately chosen to match the number of sections.  Each `.to()` call
      // executes over one unit of the timeline.
      const tl = gsap.timeline({
        scrollTrigger: {
          trigger: '#sections',
          start: 'top top',
          end: 'bottom bottom',
          scrub: true,
        },
      });

      // Define desired states for each section.  Each state defines the
      // rotation (in radians) and camera z position (zoom).  You can adjust
      // these values or extend the array if you add more sections.
      const states = [
        { rot: { x: 0, y: 0, z: 0 }, zoom: 4 },
        { rot: { x: 0.2, y: Math.PI / 2, z: 0 }, zoom: 5 },
        { rot: { x: -0.3, y: Math.PI, z: 0.1 }, zoom: 3 },
        { rot: { x: 0.4, y: 3 * Math.PI / 2, z: -0.2 }, zoom: 6 },
      ];

      // For each state, append animations to the timeline.  The '<' symbol
      // aligns both animations to start at the same time within their
      // respective segment.  Because `scrub` is true, the transitions are
      // synchronised with the scroll position.
      states.forEach((state) => {
        tl.to(model.rotation, {
          x: state.rot.x,
          y: state.rot.y,
          z: state.rot.z,
          duration: 1,
          ease: 'none',
        });
        tl.to(
          camera.position,
          {
            z: state.zoom,
            duration: 1,
            ease: 'none',
          },
          '<'
        );
      });
    }

    // Bootstrap the experience
    initThree();
    loadModel();
  </script>
</body>
</html>
